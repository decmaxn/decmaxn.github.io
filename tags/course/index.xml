<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>course - Tag - Victor Ma</title><link>https://decmaxn.github.io/tags/course/</link><description>course - Tag - Victor Ma</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 01 Apr 2023 22:22:19 -0400</lastBuildDate><atom:link href="https://decmaxn.github.io/tags/course/" rel="self" type="application/rss+xml"/><item><title>Reflect</title><link>https://decmaxn.github.io/go/reflect/</link><pubDate>Sat, 01 Apr 2023 22:22:19 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/reflect/</guid><description><![CDATA[反射机制主要由 reflect 包提供支持。通过反射，我们可以在运行时动态地获取和设置一个变量的值、类型和属性，而不需要在编码时就确定这些信息。
使用 reflect 包获取一个变量的类型和值 由于反射机制会带来一些性能上的开销，因此在性能敏感的场景中应该谨慎使用。
1 2 3 4 5 6 7 8 9 10 11 12  package main import ( &#34;fmt&#34; &#34;reflect&#34; ) func main() { var x float64 = 3.14 fmt.Println(&#34;type:&#34;, reflect.TypeOf(x)) fmt.Println(&#34;value:&#34;, reflect.ValueOf(x).Float()) }   better to use reflect for Struct 通过反射获取结构体的类型信息、字段信息和方法信息
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  package main import ( &#34;fmt&#34; &#34;reflect&#34; ) type Person struct { Name string Age int } func main() { p := Person{&#34;John&#34;, 30} // 获取结构体类型  t := reflect.]]></description></item><item><title>Defer Panic Recovery</title><link>https://decmaxn.github.io/go/defer-panic-recovery/</link><pubDate>Fri, 31 Mar 2023 21:50:16 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/defer-panic-recovery/</guid><description><![CDATA[Defer 在函数返回之前执行 等同于 Java和C# 的 finally
常使用在记的关闭你打开的资源， 比如文件，锁，错误处理等。
如果不用defer, 而是简单的把关闭动作放到逻辑后面，如果执行逻辑时出错退出，关闭就被跳过了。
Panic 和 Recover Panic主动使当前线程 crash， Recover函数从panic或错误场景中恢复
解释使用方法的 Example 1 2 3 4 5 6 7 8 9  defer func() { fmt.Println(&#34;defer func is called&#34;) if err := recover(); err != nil { fmt.Println(err) } }() panic(&#34;a panic is triggered&#34;) // defer func is called // a panic is triggered   实际使用的example 如果 doSomething() 里panic, defer 的函数会执行，包括recovery 的部分，因为mainI()里的panic
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  func main() { defer func() { // 因为有panic，recover() 会得到非nil  if r := recover(); r !]]></description></item><item><title>Nil Interface</title><link>https://decmaxn.github.io/go/nil-interface/</link><pubDate>Thu, 30 Mar 2023 19:01:09 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/nil-interface/</guid><description><![CDATA[nil interface 空接口 1 2 3 4 5 6 7 8 9 10  var data interface{} // 定义一个空接口变量  data = 42 // 将整数赋值给接口变量 fmt.Println(data) // 输出 42  data = &#34;hello&#34; // 将字符串赋值给接口变量 fmt.Println(data) // 输出 &#34;hello&#34;  data = []int{1, 2, 3} // 将整数切片赋值给接口变量 fmt.Println(data) // 输出 [1 2 3]   判空操作 试图对一个空接口进行方法调用时，就会引发一个 nil panic，导致程序崩溃。
1 2 3 4 5  func main() { var data interface{} s := data.]]></description></item><item><title>Interface</title><link>https://decmaxn.github.io/go/interface/</link><pubDate>Wed, 29 Mar 2023 22:35:58 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/interface/</guid><description>An examle of Interface 接口（interface）在 Go 语言中是一种类型, 它定义了一组方法的集合. 如果某个类型实现了接口中定义的所有方法，那么该类型就可以被认为是实现了该接口。 实际上就是方法的抽象
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 //定义一个名为 Shape 的接口类型，它包含了一个计算面积的方法 Area type Shape interface { Area() float64 // 接口是一组方法的签名（signature）集合 // Method2(args) returnType // Method3(args) returnType } //定义两个具体struct类型 Rectangle 和 Circle， type Rectangle struct { width, height float64 } type Circle struct { radius float64 } // 它们都实现了 Shape 接口中的 Area(此例中是全部)方法，用于计算矩形和圆形的面积 func (r Rectangle) Area() float64 { return r.</description></item><item><title>Method</title><link>https://decmaxn.github.io/go/method/</link><pubDate>Tue, 28 Mar 2023 22:35:58 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/method/</guid><description>Medthod vs. Function 方法（method）和函数（function）都是用于封装一段代码以便重复使用的工具，但:
方法是与特定类型相关联的函数，它们通过接收器（receiver）来绑定到某个类型上。在方法内部，可以使用接收器来访问该类型的成员变量或方法，从而实现对该类型的操作
函数是一段独立的代码块，在函数内部，可以访问函数内定义的变量，但不能访问其他作用域内的变量或函数。
因此，方法和函数的主要区别在于：
方法是与特定类型相关联的，而函数是独立的。 方法需要通过接收器来访问类型的成员变量或方法，而函数只能访问函数内定义的变量。 方法的定义方式需要指定接收器和方法名称，而函数的定义方式只需要指定函数名称(其实还要包的名字做前缀)即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 先定义一个结构体，名为 Rectangle。 用作 Area和Scale 方法的Receiver type Rectangle struct { width, height float64 } // 定义方法 Area用于计算矩形面积， func (r Rectangle) Area() float64 { // 在 Area 方法内部，我们通过 receiver r 来访问 Rectangle 类型的成员变量 width 和 height return r.</description></item><item><title>Function</title><link>https://decmaxn.github.io/go/function/</link><pubDate>Fri, 24 Mar 2023 19:34:48 +0000</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/function/</guid><description><![CDATA[声明 func identifier(输入参数) (输出参数) {body 逻辑}
main function Default entry
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package main import ( &#34;fmt&#34; ) func main() { err, result := DuplicateString(&#34;humble&#34;) if err != nil { //因为Go多值返回被用于错误处理，这句大量被使用 	fmt.Println(err) } else { fmt.Println(result) } } // 如果一个函数需要返回一个错误，可以将其定义为返回值的第一个元素，并将其类型指定为 error。 // 这里的 (input string) 是一个string类型的输入值 // 这里的 (error, string) 实际上是两个类型，分别是 error 和 string。放在一起表示返回两个值 func DuplicateString(input string) (error, string) { if input == &#34;humble&#34; { return fmt.]]></description></item><item><title>Flow Control</title><link>https://decmaxn.github.io/go/flow-control/</link><pubDate>Tue, 21 Mar 2023 21:56:10 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/flow-control/</guid><description><![CDATA[if 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  package main import &#34;fmt&#34; func main() { var x int = 5 // if x:= 5; x &gt;10 { 类似 for, 可以在条件表达式前执行一个简单语句。这里可以取代上下两句  if x &gt; 10 { fmt.Println(&#34;x is greater than 10&#34;) } else if x &gt; 5 { fmt.Println(&#34;x is greater than 5 but not greater than 10&#34;) } else { fmt.]]></description></item><item><title>Go Commands</title><link>https://decmaxn.github.io/go/go-commands/</link><pubDate>Tue, 21 Mar 2023 21:27:49 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/go-commands/</guid><description>Some go commands build - complile packages and dependencies 1 2 3 4 5 6 7 8 $ go build main.go $ ls main main.go $ ./main Hello world $ GOOS=linux GOARCH=amd64 go build main.go $ ./main error if this is not linux os and amd64 arch fmt, like linter - gofmt(reformat) package sources 1 $ go fmt main.go get - add dependencies to current module and install them 1 2 3 $ go get github.</description></item><item><title>Command Line Parameters</title><link>https://decmaxn.github.io/go/command-line-parameters/</link><pubDate>Mon, 20 Mar 2023 22:08:44 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/command-line-parameters/</guid><description><![CDATA[Example from https://github.com/cncamp/golang.git
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  $ cat &lt;&lt;EOF &gt; main.go &gt; package main &gt; &gt; import ( &gt; &#34;flag&#34; &gt; &#34;fmt&#34; &gt; &#34;os&#34; &gt; ) &gt; &gt; func main() { &gt; name := flag.String(&#34;name&#34;, &#34;world&#34;, &#34;specify the name you want to say hi&#34;) &gt; flag.]]></description></item><item><title>Private Registry Configmesh</title><link>https://decmaxn.github.io/k8s/private-registry-configmesh/</link><pubDate>Sun, 19 Mar 2023 21:37:31 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/k8s/private-registry-configmesh/</guid><description>Pulling a Container from a Private Container Registry Create a private image and prove it&amp;rsquo;s private 1 2 3 4 5 6 7 8 9 10 11 12 13 $ sudo ctr images pull psk8s.azurecr.io/hello-app:1.0 $ sudo ctr images tag psk8s.azurecr.io/hello-app:1.0 docker.io/decmaxn/test:1.0 docker.io/decmaxn/test:1.0 $ sudo ctr images push docker.io/decmaxn/test:1.0 --user decmaxn Password: manifest-sha256:a3af38fd5a7dbfe9328f71b00d04516e8e9c778b4886e8aaac8d9e8862a09bc7: done |++++++++++++++++++++++++++++++++++++++| config-sha256:7f20d355455edaaad01555f1a9520782675cf7b228ffd0527fb1349626b0ddb1: done |++++++++++++++++++++++++++++++++++++++| elapsed: 12.7s total: 2.2 Ki (179.0 B/s) $ sudo ctr images pull docker.</description></item></channel></rss>