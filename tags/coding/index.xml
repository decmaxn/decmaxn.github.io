<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>coding - Tag - Victor Ma</title><link>https://decmaxn.github.io/tags/coding/</link><description>coding - Tag - Victor Ma</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 30 Mar 2023 19:01:09 -0400</lastBuildDate><atom:link href="https://decmaxn.github.io/tags/coding/" rel="self" type="application/rss+xml"/><item><title>Nil Interface</title><link>https://decmaxn.github.io/go/nil-interface/</link><pubDate>Thu, 30 Mar 2023 19:01:09 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/nil-interface/</guid><description><![CDATA[nil interface 空接口 1 2 3 4 5 6 7 8 9 10  var data interface{} // 定义一个空接口变量  data = 42 // 将整数赋值给接口变量 fmt.Println(data) // 输出 42  data = &#34;hello&#34; // 将字符串赋值给接口变量 fmt.Println(data) // 输出 &#34;hello&#34;  data = []int{1, 2, 3} // 将整数切片赋值给接口变量 fmt.Println(data) // 输出 [1 2 3]   判空操作 试图对一个空接口进行方法调用时，就会引发一个 nil panic，导致程序崩溃。
1 2 3 4 5  func main() { var data interface{} s := data.]]></description></item><item><title>Interface</title><link>https://decmaxn.github.io/go/interface/</link><pubDate>Wed, 29 Mar 2023 22:35:58 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/interface/</guid><description>An examle of Interface 接口（interface）在 Go 语言中是一种类型, 它定义了一组方法的集合. 如果某个类型实现了接口中定义的所有方法，那么该类型就可以被认为是实现了该接口。 实际上就是方法的抽象
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 //定义一个名为 Shape 的接口类型，它包含了一个计算面积的方法 Area type Shape interface { Area() float64 // 接口是一组方法的签名（signature）集合 // Method2(args) returnType // Method3(args) returnType } //定义两个具体struct类型 Rectangle 和 Circle， type Rectangle struct { width, height float64 } type Circle struct { radius float64 } // 它们都实现了 Shape 接口中的 Area(此例中是全部)方法，用于计算矩形和圆形的面积 func (r Rectangle) Area() float64 { return r.</description></item><item><title>Method</title><link>https://decmaxn.github.io/go/method/</link><pubDate>Tue, 28 Mar 2023 22:35:58 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/method/</guid><description>Medthod vs. Function 方法（method）和函数（function）都是用于封装一段代码以便重复使用的工具，但:
方法是与特定类型相关联的函数，它们通过接收器（receiver）来绑定到某个类型上。在方法内部，可以使用接收器来访问该类型的成员变量或方法，从而实现对该类型的操作
函数是一段独立的代码块，在函数内部，可以访问函数内定义的变量，但不能访问其他作用域内的变量或函数。
因此，方法和函数的主要区别在于：
方法是与特定类型相关联的，而函数是独立的。 方法需要通过接收器来访问类型的成员变量或方法，而函数只能访问函数内定义的变量。 方法的定义方式需要指定接收器和方法名称，而函数的定义方式只需要指定函数名称(其实还要包的名字做前缀)即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 先定义一个结构体，名为 Rectangle。 用作 Area和Scale 方法的Receiver type Rectangle struct { width, height float64 } // 定义方法 Area用于计算矩形面积， func (r Rectangle) Area() float64 { // 在 Area 方法内部，我们通过 receiver r 来访问 Rectangle 类型的成员变量 width 和 height return r.</description></item><item><title>Function</title><link>https://decmaxn.github.io/go/function/</link><pubDate>Fri, 24 Mar 2023 19:34:48 +0000</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/function/</guid><description><![CDATA[声明 func identifier(输入参数) (输出参数) {body 逻辑}
main function Default entry
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package main import ( &#34;fmt&#34; ) func main() { err, result := DuplicateString(&#34;humble&#34;) if err != nil { //因为Go多值返回被用于错误处理，这句大量被使用 	fmt.Println(err) } else { fmt.Println(result) } } // 如果一个函数需要返回一个错误，可以将其定义为返回值的第一个元素，并将其类型指定为 error。 // 这里的 (input string) 是一个string类型的输入值 // 这里的 (error, string) 实际上是两个类型，分别是 error 和 string。放在一起表示返回两个值 func DuplicateString(input string) (error, string) { if input == &#34;humble&#34; { return fmt.]]></description></item><item><title>Flow Control</title><link>https://decmaxn.github.io/go/flow-control/</link><pubDate>Tue, 21 Mar 2023 21:56:10 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/flow-control/</guid><description><![CDATA[if 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  package main import &#34;fmt&#34; func main() { var x int = 5 // if x:= 5; x &gt;10 { 类似 for, 可以在条件表达式前执行一个简单语句。这里可以取代上下两句  if x &gt; 10 { fmt.Println(&#34;x is greater than 10&#34;) } else if x &gt; 5 { fmt.Println(&#34;x is greater than 5 but not greater than 10&#34;) } else { fmt.]]></description></item><item><title>Go Commands</title><link>https://decmaxn.github.io/go/go-commands/</link><pubDate>Tue, 21 Mar 2023 21:27:49 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/go-commands/</guid><description>Some go commands build - complile packages and dependencies 1 2 3 4 5 6 7 8 $ go build main.go $ ls main main.go $ ./main Hello world $ GOOS=linux GOARCH=amd64 go build main.go $ ./main error if this is not linux os and amd64 arch fmt, like linter - gofmt(reformat) package sources 1 $ go fmt main.go get - add dependencies to current module and install them 1 2 3 $ go get github.</description></item><item><title>Command Line Parameters</title><link>https://decmaxn.github.io/go/command-line-parameters/</link><pubDate>Mon, 20 Mar 2023 22:08:44 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/command-line-parameters/</guid><description><![CDATA[Example from https://github.com/cncamp/golang.git
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  $ cat &lt;&lt;EOF &gt; main.go &gt; package main &gt; &gt; import ( &gt; &#34;flag&#34; &gt; &#34;fmt&#34; &gt; &#34;os&#34; &gt; ) &gt; &gt; func main() { &gt; name := flag.String(&#34;name&#34;, &#34;world&#34;, &#34;specify the name you want to say hi&#34;) &gt; flag.]]></description></item><item><title>Devcontainer_tdd</title><link>https://decmaxn.github.io/go/devcontainer_tdd/</link><pubDate>Sun, 26 Feb 2023 23:11:54 -0500</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/devcontainer_tdd/</guid><description>.devcontainer Run vscode command palette, Dev Conainter and search universal, this way to get Codespaces default container. Later on add pwsh.
TDD: Test-driven development Follow Hello world to practice TDD.</description></item><item><title>collections</title><link>https://decmaxn.github.io/go/collections/</link><pubDate>Sun, 26 Feb 2023 16:35:38 -0500</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/collections/</guid><description><![CDATA[Map Map can store any types key and value pairs, there is no order. There is no fixed size, so you can tell it&rsquo;s a pointer.
Key 不能是复杂的，不能比较的type.
声明 We have to give map key word to tell it&rsquo;s type, it&rsquo;s not like this before. Follow that is key type in [] and value type.
1 2 3 4 5 6 7 8 9 10 11 12 13  m := map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2} fmt.]]></description></item><item><title>Array_slice</title><link>https://decmaxn.github.io/go/array_slice/</link><pubDate>Sun, 26 Feb 2023 15:48:50 -0500</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/array_slice/</guid><description><![CDATA[Array It&rsquo;s similar with Python&rsquo;s array. In Go, array is also a continues memoery block in fixed size, so it&rsquo;s faster but not dynamic.
It also stores same type objects. What different is Go array is not a pointer.
1 2 3 4 5 6 7 8 9  var myarray [3]int // signature of array is [size]type 	fmt.Println(myarray) // [0 0 0] 	myarray[0] = 3 fmt.Println(myarray[0]) // 3 	arr := [3]int{1, 2, 3} // declare implicitly, it&#39;s not [1 2 3] 	fmt.]]></description></item></channel></rss>