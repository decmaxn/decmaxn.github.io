<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>coding - Tag - Victor Ma</title><link>https://decmaxn.github.io/tags/coding/</link><description>coding - Tag - Victor Ma</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 20 Apr 2023 21:23:17 -0400</lastBuildDate><atom:link href="https://decmaxn.github.io/tags/coding/" rel="self" type="application/rss+xml"/><item><title>Anonymous Function</title><link>https://decmaxn.github.io/go/anonymous-function/</link><pubDate>Thu, 20 Apr 2023 21:23:17 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/anonymous-function/</guid><description>闭包 （匿名函数） 不能独立存在，只能存在于其他函数中 可以赋值给其他变量 x:=func(){}，其实就是声明 函数也是一种数据类型，因为它虽然不是变量，但是存在于内存中的地址块。函数名的本质是一个指向其内存地址的针常量。
可以直接掉用 func(x,y int){println(x+y)}(1,2) 注意直接调用是在声明的后面加上参数，其实就是 invoke 的格式。
function 不等同于 invoke function
可以作为函数返回值 func：表示这是一个函数。 Add：是函数的名称。 ()：是函数的参数列表。在这个例子中，Add 函数没有接受任何参数。 (func(b int) int)：是函数的返回类型是一个函数。 这个函数接受一个整数参数 b，返回一个整数值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func Add() (func(b int) int) { sum := 0 // 返回一个函数，该函数将参数与 sum 相加并返回 return func(b int) int { sum += b return sum } } func main() { // addFunc 就是那个返回的函数 addFunc := Add() result := addFunc(5) // 调用返回的函数，将 5 与 sum 相加 fmt.</description></item><item><title>Simple Web Server 1</title><link>https://decmaxn.github.io/go/simple-web-server-1/</link><pubDate>Tue, 04 Apr 2023 23:17:25 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/simple-web-server-1/</guid><description><![CDATA[Simple web API server to put everything together main.go
1 2 3 4 5 6 7 8 9 10 11 12  package main import ( &#34;net/http&#34; &#34;github.com/pluralsight/webservice/controllers&#34; ) func main() { controllers.RegisterControllers() http.ListenAndServe(&#34;:3000&#34;, nil) }   controllers/front.go
1 2 3 4 5 6 7 8 9 10 11  package controllers import &#34;net/http&#34; func RegisterControllers() { uc := newUserController() // uc 是一个指向 userController 结构体的指针类型，因此需要使用 *uc 表示 uc 所指向的实际对象。  // 使用 *uc 就是为了将 uc 指针类型转换为 Handler 接口类型。  http.]]></description></item><item><title>Dns From Name Tag</title><link>https://decmaxn.github.io/python/dns-from-name-tag/</link><pubDate>Mon, 03 Apr 2023 01:25:46 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/python/dns-from-name-tag/</guid><description>Create Route53 records based on EC2 Tags.Name There might have duplicated Tags.Name, so array is used to pick them up and manipulate. Tags.Name might include charactors not qualified for dns name, regular expression is used to remove them. There might be no Tags.Name, next()函数and返回生成器is used. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 import boto3 import re import json session = boto3.</description></item><item><title>Reflect</title><link>https://decmaxn.github.io/go/reflect/</link><pubDate>Sat, 01 Apr 2023 22:22:19 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/reflect/</guid><description><![CDATA[反射机制主要由 reflect 包提供支持。通过反射，我们可以在运行时动态地获取和设置一个变量的值、类型和属性，而不需要在编码时就确定这些信息。
使用 reflect 包获取一个变量的类型和值 由于反射机制会带来一些性能上的开销，因此在性能敏感的场景中应该谨慎使用。
1 2 3 4 5 6 7 8 9 10 11 12  package main import ( &#34;fmt&#34; &#34;reflect&#34; ) func main() { var x float64 = 3.14 fmt.Println(&#34;type:&#34;, reflect.TypeOf(x)) fmt.Println(&#34;value:&#34;, reflect.ValueOf(x).Float()) }   better to use reflect for Struct 通过反射获取结构体的类型信息、字段信息和方法信息
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  package main import ( &#34;fmt&#34; &#34;reflect&#34; ) type Person struct { Name string Age int } func main() { p := Person{&#34;John&#34;, 30} // 获取结构体类型  t := reflect.]]></description></item><item><title>Defer Panic Recovery</title><link>https://decmaxn.github.io/go/defer-panic-recovery/</link><pubDate>Fri, 31 Mar 2023 21:50:16 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/defer-panic-recovery/</guid><description><![CDATA[Defer 在函数返回之前执行 等同于 Java和C# 的 finally
常使用在记的关闭你打开的资源， 比如文件，锁，错误处理等。
如果不用defer, 而是简单的把关闭动作放到逻辑后面，如果执行逻辑时出错退出，关闭就被跳过了。
Panic 和 Recover Panic主动使当前线程 crash， Recover函数从panic或错误场景中恢复
解释使用方法的 Example 1 2 3 4 5 6 7 8 9  defer func() { fmt.Println(&#34;defer func is called&#34;) if err := recover(); err != nil { fmt.Println(err) } }() panic(&#34;a panic is triggered&#34;) // defer func is called // a panic is triggered   实际使用的example 如果 doSomething() 里panic, defer 的函数会执行，包括recovery 的部分，因为mainI()里的panic
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  func main() { defer func() { // 因为有panic，recover() 会得到非nil  if r := recover(); r !]]></description></item><item><title>Nil Interface</title><link>https://decmaxn.github.io/go/nil-interface/</link><pubDate>Thu, 30 Mar 2023 19:01:09 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/nil-interface/</guid><description><![CDATA[nil interface 空接口 1 2 3 4 5 6 7 8 9 10  var data interface{} // 定义一个空接口变量  data = 42 // 将整数赋值给接口变量 fmt.Println(data) // 输出 42  data = &#34;hello&#34; // 将字符串赋值给接口变量 fmt.Println(data) // 输出 &#34;hello&#34;  data = []int{1, 2, 3} // 将整数切片赋值给接口变量 fmt.Println(data) // 输出 [1 2 3]   判空操作 试图对一个空接口进行方法调用时，就会引发一个 nil panic，导致程序崩溃。
1 2 3 4 5  func main() { var data interface{} s := data.]]></description></item><item><title>Interface</title><link>https://decmaxn.github.io/go/interface/</link><pubDate>Wed, 29 Mar 2023 22:35:58 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/interface/</guid><description>An examle of Interface 接口（interface）在 Go 语言中是一种类型, 它定义了一组方法的集合. 如果某个类型实现了接口中定义的所有方法，那么该类型就可以被认为是实现了该接口。 实际上就是方法的抽象
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 //定义一个名为 Shape 的接口类型，它包含了一个计算面积的方法 Area type Shape interface { Area() float64 // 接口是一组方法的签名（signature）集合 // Method2(args) returnType // Method3(args) returnType } //定义两个具体struct类型 Rectangle 和 Circle， type Rectangle struct { width, height float64 } type Circle struct { radius float64 } // 它们都实现了 Shape 接口中的 Area(此例中是全部)方法，用于计算矩形和圆形的面积 func (r Rectangle) Area() float64 { return r.</description></item><item><title>Method</title><link>https://decmaxn.github.io/go/method/</link><pubDate>Tue, 28 Mar 2023 22:35:58 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/method/</guid><description>Medthod vs. Function 方法（method）和函数（function）都是用于封装一段代码以便重复使用的工具，但:
方法是与特定类型相关联的函数，它们通过接收器（receiver）来绑定到某个类型上。在方法内部，可以使用接收器来访问该类型的成员变量或方法，从而实现对该类型的操作
函数是一段独立的代码块，在函数内部，可以访问函数内定义的变量，但不能访问其他作用域内的变量或函数。
因此，方法和函数的主要区别在于：
方法是与特定类型相关联的，而函数是独立的。 方法需要通过接收器来访问类型的成员变量或方法，而函数只能访问函数内定义的变量。 方法的定义方式需要指定接收器和方法名称，而函数的定义方式只需要指定函数名称(其实还要包的名字做前缀)即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 先定义一个结构体，名为 Rectangle。 用作 Area和Scale 方法的Receiver type Rectangle struct { width, height float64 } // 定义方法 Area用于计算矩形面积， func (r Rectangle) Area() float64 { // 在 Area 方法内部，我们通过 receiver r 来访问 Rectangle 类型的成员变量 width 和 height return r.</description></item><item><title>Function</title><link>https://decmaxn.github.io/go/function/</link><pubDate>Fri, 24 Mar 2023 19:34:48 +0000</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/function/</guid><description><![CDATA[声明 func identifier(输入参数) (输出参数) {body 逻辑}
main function Default entry
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package main import ( &#34;fmt&#34; ) func main() { err, result := DuplicateString(&#34;humble&#34;) if err != nil { //因为Go多值返回被用于错误处理，这句大量被使用 	fmt.Println(err) } else { fmt.Println(result) } } // 如果一个函数需要返回一个错误，可以将其定义为返回值的第一个元素，并将其类型指定为 error。 // 这里的 (input string) 是一个string类型的输入值 // 这里的 (error, string) 实际上是两个类型，分别是 error 和 string。放在一起表示返回两个值 func DuplicateString(input string) (error, string) { if input == &#34;humble&#34; { return fmt.]]></description></item><item><title>Flow Control</title><link>https://decmaxn.github.io/go/flow-control/</link><pubDate>Tue, 21 Mar 2023 21:56:10 -0400</pubDate><author>Victor Ma</author><guid>https://decmaxn.github.io/go/flow-control/</guid><description><![CDATA[if 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  package main import &#34;fmt&#34; func main() { var x int = 5 // if x:= 5; x &gt;10 { 类似 for, 可以在条件表达式前执行一个简单语句。这里可以取代上下两句  if x &gt; 10 { fmt.Println(&#34;x is greater than 10&#34;) } else if x &gt; 5 { fmt.Println(&#34;x is greater than 5 but not greater than 10&#34;) } else { fmt.]]></description></item></channel></rss>