<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Gos on Victor Ma</title><link>https://decmaxn.github.io/go/</link><description>Recent content in Gos on Victor Ma</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 04 Apr 2023 23:17:25 -0400</lastBuildDate><atom:link href="https://decmaxn.github.io/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Simple Web Server 1</title><link>https://decmaxn.github.io/go/simple-web-server-1/</link><pubDate>Tue, 04 Apr 2023 23:17:25 -0400</pubDate><guid>https://decmaxn.github.io/go/simple-web-server-1/</guid><description>Simple web API server to put everything together main.go
1 2 3 4 5 6 7 8 9 10 11 12 package main import ( &amp;#34;net/http&amp;#34; &amp;#34;github.com/pluralsight/webservice/controllers&amp;#34; ) func main() { controllers.RegisterControllers() http.ListenAndServe(&amp;#34;:3000&amp;#34;, nil) } controllers/front.go
1 2 3 4 5 6 7 8 9 10 11 package controllers import &amp;#34;net/http&amp;#34; func RegisterControllers() { uc := newUserController() // uc 是一个指向 userController 结构体的指针类型，因此需要使用 *uc 表示 uc 所指向的实际对象。 // 使用 *uc 就是为了将 uc 指针类型转换为 Handler 接口类型。 http.</description></item><item><title>Reflect</title><link>https://decmaxn.github.io/go/reflect/</link><pubDate>Sat, 01 Apr 2023 22:22:19 -0400</pubDate><guid>https://decmaxn.github.io/go/reflect/</guid><description>反射机制主要由 reflect 包提供支持。通过反射，我们可以在运行时动态地获取和设置一个变量的值、类型和属性，而不需要在编码时就确定这些信息。
使用 reflect 包获取一个变量的类型和值 由于反射机制会带来一些性能上的开销，因此在性能敏感的场景中应该谨慎使用。
1 2 3 4 5 6 7 8 9 10 11 12 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; ) func main() { var x float64 = 3.14 fmt.Println(&amp;#34;type:&amp;#34;, reflect.TypeOf(x)) fmt.Println(&amp;#34;value:&amp;#34;, reflect.ValueOf(x).Float()) } better to use reflect for Struct 通过反射获取结构体的类型信息、字段信息和方法信息
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; ) type Person struct { Name string Age int } func main() { p := Person{&amp;#34;John&amp;#34;, 30} // 获取结构体类型 t := reflect.</description></item><item><title>Defer Panic Recovery</title><link>https://decmaxn.github.io/go/defer-panic-recovery/</link><pubDate>Fri, 31 Mar 2023 21:50:16 -0400</pubDate><guid>https://decmaxn.github.io/go/defer-panic-recovery/</guid><description>Defer 在函数返回之前执行 等同于 Java和C# 的 finally
常使用在记的关闭你打开的资源， 比如文件，锁，错误处理等。
如果不用defer, 而是简单的把关闭动作放到逻辑后面，如果执行逻辑时出错退出，关闭就被跳过了。
Panic 和 Recover Panic主动使当前线程 crash， Recover函数从panic或错误场景中恢复
解释使用方法的 Example 1 2 3 4 5 6 7 8 9 defer func() { fmt.Println(&amp;#34;defer func is called&amp;#34;) if err := recover(); err != nil { fmt.Println(err) } }() panic(&amp;#34;a panic is triggered&amp;#34;) // defer func is called // a panic is triggered 实际使用的example 如果 doSomething() 里panic, defer 的函数会执行，包括recovery 的部分，因为mainI()里的panic
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func main() { defer func() { // 因为有panic，recover() 会得到非nil if r := recover(); r !</description></item><item><title>Nil Interface</title><link>https://decmaxn.github.io/go/nil-interface/</link><pubDate>Thu, 30 Mar 2023 19:01:09 -0400</pubDate><guid>https://decmaxn.github.io/go/nil-interface/</guid><description>nil interface 空接口 1 2 3 4 5 6 7 8 9 10 var data interface{} // 定义一个空接口变量 data = 42 // 将整数赋值给接口变量 fmt.Println(data) // 输出 42 data = &amp;#34;hello&amp;#34; // 将字符串赋值给接口变量 fmt.Println(data) // 输出 &amp;#34;hello&amp;#34; data = []int{1, 2, 3} // 将整数切片赋值给接口变量 fmt.Println(data) // 输出 [1 2 3] 判空操作 试图对一个空接口进行方法调用时，就会引发一个 nil panic，导致程序崩溃。
1 2 3 4 5 func main() { var data interface{} s := data.</description></item><item><title>Interface</title><link>https://decmaxn.github.io/go/interface/</link><pubDate>Wed, 29 Mar 2023 22:35:58 -0400</pubDate><guid>https://decmaxn.github.io/go/interface/</guid><description>An examle of Interface 接口（interface）在 Go 语言中是一种类型, 它定义了一组方法的集合. 如果某个类型实现了接口中定义的所有方法，那么该类型就可以被认为是实现了该接口。 实际上就是方法的抽象
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 //定义一个名为 Shape 的接口类型，它包含了一个计算面积的方法 Area type Shape interface { Area() float64 // 接口是一组方法的签名（signature）集合 // Method2(args) returnType // Method3(args) returnType } //定义两个具体struct类型 Rectangle 和 Circle， type Rectangle struct { width, height float64 } type Circle struct { radius float64 } // 它们都实现了 Shape 接口中的 Area(此例中是全部)方法，用于计算矩形和圆形的面积 func (r Rectangle) Area() float64 { return r.</description></item><item><title>Method</title><link>https://decmaxn.github.io/go/method/</link><pubDate>Tue, 28 Mar 2023 22:35:58 -0400</pubDate><guid>https://decmaxn.github.io/go/method/</guid><description>Medthod vs. Function 方法（method）和函数（function）都是用于封装一段代码以便重复使用的工具，但:
方法是与特定类型相关联的函数，它们通过接收器（receiver）来绑定到某个类型上。在方法内部，可以使用接收器来访问该类型的成员变量或方法，从而实现对该类型的操作
函数是一段独立的代码块，在函数内部，可以访问函数内定义的变量，但不能访问其他作用域内的变量或函数。
因此，方法和函数的主要区别在于：
方法是与特定类型相关联的，而函数是独立的。 方法需要通过接收器来访问类型的成员变量或方法，而函数只能访问函数内定义的变量。 方法的定义方式需要指定接收器和方法名称，而函数的定义方式只需要指定函数名称(其实还要包的名字做前缀)即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 先定义一个结构体，名为 Rectangle。 用作 Area和Scale 方法的Receiver type Rectangle struct { width, height float64 } // 定义方法 Area用于计算矩形面积， func (r Rectangle) Area() float64 { // 在 Area 方法内部，我们通过 receiver r 来访问 Rectangle 类型的成员变量 width 和 height return r.</description></item><item><title>Function</title><link>https://decmaxn.github.io/go/function/</link><pubDate>Fri, 24 Mar 2023 19:34:48 +0000</pubDate><guid>https://decmaxn.github.io/go/function/</guid><description>声明 func identifier(输入参数) (输出参数) {body 逻辑}
main function Default entry
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( &amp;#34;fmt&amp;#34; ) func main() { err, result := DuplicateString(&amp;#34;humble&amp;#34;) if err != nil { //因为Go多值返回被用于错误处理，这句大量被使用 fmt.Println(err) } else { fmt.Println(result) } } // 如果一个函数需要返回一个错误，可以将其定义为返回值的第一个元素，并将其类型指定为 error。 // 这里的 (input string) 是一个string类型的输入值 // 这里的 (error, string) 实际上是两个类型，分别是 error 和 string。放在一起表示返回两个值 func DuplicateString(input string) (error, string) { if input == &amp;#34;humble&amp;#34; { return fmt.</description></item><item><title>Flow Control</title><link>https://decmaxn.github.io/go/flow-control/</link><pubDate>Tue, 21 Mar 2023 21:56:10 -0400</pubDate><guid>https://decmaxn.github.io/go/flow-control/</guid><description>if 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import &amp;#34;fmt&amp;#34; func main() { var x int = 5 // if x:= 5; x &amp;gt;10 { 类似 for, 可以在条件表达式前执行一个简单语句。这里可以取代上下两句 if x &amp;gt; 10 { fmt.Println(&amp;#34;x is greater than 10&amp;#34;) } else if x &amp;gt; 5 { fmt.Println(&amp;#34;x is greater than 5 but not greater than 10&amp;#34;) } else { fmt.</description></item><item><title>Go Commands</title><link>https://decmaxn.github.io/go/go-commands/</link><pubDate>Tue, 21 Mar 2023 21:27:49 -0400</pubDate><guid>https://decmaxn.github.io/go/go-commands/</guid><description>Some go commands build - complile packages and dependencies 1 2 3 4 5 6 7 8 $ go build main.go $ ls main main.go $ ./main Hello world $ GOOS=linux GOARCH=amd64 go build main.go $ ./main error if this is not linux os and amd64 arch fmt, like linter - gofmt(reformat) package sources 1 $ go fmt main.go get - add dependencies to current module and install them 1 2 3 $ go get github.</description></item><item><title>Command Line Parameters</title><link>https://decmaxn.github.io/go/command-line-parameters/</link><pubDate>Mon, 20 Mar 2023 22:08:44 -0400</pubDate><guid>https://decmaxn.github.io/go/command-line-parameters/</guid><description>Example from https://github.com/cncamp/golang.git
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 $ cat &amp;lt;&amp;lt;EOF &amp;gt; main.go &amp;gt; package main &amp;gt; &amp;gt; import ( &amp;gt; &amp;#34;flag&amp;#34; &amp;gt; &amp;#34;fmt&amp;#34; &amp;gt; &amp;#34;os&amp;#34; &amp;gt; ) &amp;gt; &amp;gt; func main() { &amp;gt; name := flag.String(&amp;#34;name&amp;#34;, &amp;#34;world&amp;#34;, &amp;#34;specify the name you want to say hi&amp;#34;) &amp;gt; flag.</description></item><item><title>Devcontainer_tdd</title><link>https://decmaxn.github.io/go/devcontainer_tdd/</link><pubDate>Sun, 26 Feb 2023 23:11:54 -0500</pubDate><guid>https://decmaxn.github.io/go/devcontainer_tdd/</guid><description>.devcontainer Run vscode command palette, Dev Conainter and search universal, this way to get Codespaces default container. Later on add pwsh.
TDD: Test-driven development Follow Hello world to practice TDD.</description></item><item><title>collections</title><link>https://decmaxn.github.io/go/collections/</link><pubDate>Sun, 26 Feb 2023 16:35:38 -0500</pubDate><guid>https://decmaxn.github.io/go/collections/</guid><description>Map Map can store any types key and value pairs, there is no order. There is no fixed size, so you can tell it&amp;rsquo;s a pointer.
Key 不能是复杂的，不能比较的type.
声明 We have to give map key word to tell it&amp;rsquo;s type, it&amp;rsquo;s not like this before. Follow that is key type in [] and value type.
1 2 3 4 5 6 7 8 9 10 11 12 13 m := map[string]int{&amp;#34;foo&amp;#34;: 1, &amp;#34;bar&amp;#34;: 2} fmt.</description></item><item><title>Array_slice</title><link>https://decmaxn.github.io/go/array_slice/</link><pubDate>Sun, 26 Feb 2023 15:48:50 -0500</pubDate><guid>https://decmaxn.github.io/go/array_slice/</guid><description>Array It&amp;rsquo;s similar with Python&amp;rsquo;s array. In Go, array is also a continues memoery block in fixed size, so it&amp;rsquo;s faster but not dynamic.
It also stores same type objects. What different is Go array is not a pointer.
1 2 3 4 5 6 7 8 9 var myarray [3]int // signature of array is [size]type fmt.Println(myarray) // [0 0 0] myarray[0] = 3 fmt.Println(myarray[0]) // 3 arr := [3]int{1, 2, 3} // declare implicitly, it&amp;#39;s not [1 2 3] fmt.</description></item><item><title>Constant</title><link>https://decmaxn.github.io/go/constant/</link><pubDate>Sun, 26 Feb 2023 15:04:15 -0500</pubDate><guid>https://decmaxn.github.io/go/constant/</guid><description>声明 const identifier type = value
Normal side of Go constant:
declare and assign at the same time, can not be done separately. Value has to be determined in complie time, not run time The type of constant can be implicit, or explicit if you need to 1 2 3 4 5 const pi = 3 // type not assigned fmt.Println(pi) // pi is treated as int fmt.</description></item><item><title>Var_primitives_pointer</title><link>https://decmaxn.github.io/go/var_primitives_pointer/</link><pubDate>Sun, 26 Feb 2023 12:40:50 -0500</pubDate><guid>https://decmaxn.github.io/go/var_primitives_pointer/</guid><description>Declaring var with Primitive Data Types Primitive Data Types 指的是一些基本的数据类型，这些类型不依赖于其他类型，是构成更复杂的数据类型的基础
函数外的每个语句都必须以关键字开始(var, func 等等)
1 2 3 var num int num = 11 fmt.Println(num) Esay to write way:
1 2 3 4 5 var num int = 11 var greeting string = &amp;#34;Hello&amp;#34; fmt.Println(num, greeting) // 如果初始化值已存在，则可以省略类型;变量会从初始值中获得类型 var i,j = 1,2 在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。
1 2 3 num := 11 greeting := &amp;#34;Hello&amp;#34; fmt.</description></item><item><title>Install_and_Config</title><link>https://decmaxn.github.io/go/install-config/</link><pubDate>Sat, 25 Feb 2023 22:05:35 -0500</pubDate><guid>https://decmaxn.github.io/go/install-config/</guid><description>Installation download Go itself for windows and install, confirm with go version after.
1 go version go1.20.1 windows/amd64 For linux: https://go.dev/doc/install
1 2 3 4 wget https://go.dev/dl/go1.20.4.linux-amd64.tar.gz rm -rf /usr/local/go &amp;amp;&amp;amp; tar -C /usr/local -xzf go1.20.4.linux-amd64.tar.gz export PATH=$PATH:/usr/local/go/bin go version Configuration Use &amp;ldquo;go help doc&amp;rdquo; for more information about doc command 1 2 3 4 5 6 7 8 9 &amp;gt; go doc json.</description></item></channel></rss>